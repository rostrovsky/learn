<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flashcards Deck</title>
  <style>
    :root {
      --bg: #ffffff;
      --fg: #0f172a; /* slate-900 */
      --muted: #64748b; /* slate-500 */
      --accent: #111827; /* gray-900 */
      --accent-2: #e5e7eb; /* gray-200 */
      --ring: #1f2937; /* gray-800 */
      --card: #ffffff;
      --shadow: 0 8px 24px rgba(2, 6, 23, 0.08);
      --radius: 18px;
      --primary: #7c3aed; /* purple-600 */
      --primary-hover: #6d28d9; /* purple-700 */
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI,
      Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg); color: var(--fg);
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
      touch-action: manipulation; /* Prevent default touch behaviors */
    }

    .container { 
      max-width: 960px; 
      margin: 0 auto; 
      padding: 0 20px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .main-content {
      flex: 1;
    }

    header { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 18px; padding-top: 20px; }
    header h1 { font-size: clamp(20px, 2.5vw, 28px); margin: 0; letter-spacing: -0.02em; }
    header .subtitle { color: var(--muted); font-size: 14px; }

    .btn {
      appearance: none; border: 1px solid var(--accent-2); background: #fff; color: var(--fg);
      border-radius: 12px; padding: 10px 14px; font-size: 14px; cursor: pointer; 
      transition: transform .06s ease, box-shadow .2s ease, border-color .2s ease;
      box-shadow: 0 1px 0 rgba(2,6,23,0.02);
    }
    .btn:hover { border-color: #cbd5e1; }
    .btn:active { transform: translateY(1px); }
    .btn[disabled] { opacity: .45; cursor: not-allowed; }

    .btn-primary {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
      font-weight: 500;
    }
    .btn-primary:hover { background: var(--primary-hover); border-color: var(--primary-hover); }

    .controls { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin: 18px 0 8px; flex-wrap: wrap; }
    .controls .left, .controls .right { display: flex; gap: 8px; align-items: center; }

    .counter { color: var(--muted); font-size: 13px; }
    .title { font-weight: 600; }

    .card {
      position: relative;
      min-height: 220px;
      padding: clamp(18px, 3vw, 28px);
      border-radius: var(--radius);
      background: var(--card);
      box-shadow: var(--shadow);
      border: 1px solid rgba(100,116,139,0.12);
      display: grid;
      align-items: center;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    /* Touch area indicators (subtle visual feedback) */
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: var(--radius);
      pointer-events: none;
      z-index: 1;
    }

    .card.touch-left::before {
      background: linear-gradient(to right, rgba(124, 58, 237, 0.1), transparent);
    }

    .card.touch-right::before {
      background: linear-gradient(to left, rgba(124, 58, 237, 0.1), transparent);
    }

    .card.touch-center::before {
      background: linear-gradient(to right, transparent, rgba(124, 58, 237, 0.1), transparent);
    }

    .prompt { font-size: clamp(18px, 2.4vw, 26px); line-height: 1.35; letter-spacing: -0.01em; }
    .answers { display: none; }
    .answers.revealed { display: block; }
    .answers ul { margin: 8px 0 0 0; padding-left: 18px; }
    .answers li { margin: 6px 0; font-size: clamp(15px, 1.6vw, 18px); }

    .hint { color: var(--muted); font-size: 12px; text-align: center; margin-top: 10px; }

    .error { background: #fef2f2; border: 1px solid #fecaca; color: #7f1d1d; padding: 12px 14px; border-radius: 12px; font-size: 14px; }
    .error + .error { margin-top: 8px; }

    .hidden { display: none !important; }

    #cardCount { text-align: center; margin-top: 1em; margin-bottom: 1em; }

    footer { 
      margin-top: 20px; 
      color: var(--muted); 
      font-size: 12px; 
      display: flex; 
      justify-content: center;
      gap: 8px; 
      flex-wrap: wrap;
      margin-top: auto;
      padding-bottom: 20px;
      text-align: center;
    }
    code.kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background: #f3f4f6; padding: 2px 6px; border-radius: 6px; border: 1px solid #e5e7eb; }
  </style>
</head>
<body>
  <div class="container">
    <div class="main-content">
      <header>
        <div>
          <h1>Flashcards Deck</h1>
        </div>
        <div class="right">
          <button id="loadJsonBtn" class="btn btn-primary" type="button" title="Load JSON file">Load JSON</button>
          <button id="demoBtn" class="btn" type="button" title="Load a small demo deck">Load demo</button>
        </div>
      </header>

      <div id="errors" class="errors"></div>

      <div id="controls" class="controls hidden" aria-hidden="true">
        <div class="left">
          <button id="prevBtn" class="btn" title="Previous (←)">◀︎ Prev</button>
          <button id="flipBtn" class="btn" title="Flip (Space)">Flip</button>
          <button id="nextBtn" class="btn" title="Next (→)">Next ▶︎</button>
        </div>
        <div class="right">
          <button id="shuffleBtn" class="btn" title="Shuffle (S)">Shuffle</button>
          <button id="restartBtn" class="btn" title="Restart (R)">Restart</button>
        </div>
      </div>

      <div id="meta" class="counter hidden" aria-live="polite"></div>

      <section id="card" class="card hidden" aria-live="polite">
        <div>
          <div id="prompt" class="prompt"></div>
          <div id="answers" class="answers">
            <ul id="answerList"></ul>
          </div>
        </div>
      </section>
      <div id="cardCount"></div>
      <div id="hint" class="hint hidden">Press <code class="kbd">Space</code> to flip, <code class="kbd">←</code>/<code class="kbd">→</code> to navigate, <code class="kbd">S</code> to shuffle.<br>On mobile: touch sides of a card to navigate, center to flip.</div>
    </div>

    <footer>
      <div>Minimal, self‑contained. No network, no tracking.</div>
    </footer>
  </div>

  <input id="fileInput" type="file" accept="application/json,.json" class="hidden" />

  <script>
  // --- Minimal validator tailored to the given schema ---
  function validateDeck(deck) {
    const errors = [];
    const isObject = (v) => v && typeof v === 'object' && !Array.isArray(v);

    // Deck-level checks
    if (!isObject(deck)) return { ok: false, errors: ["Root must be an object."] };

    const allowedDeckKeys = new Set(["title", "version", "cards"]);
    Object.keys(deck).forEach(k => { if (!allowedDeckKeys.has(k)) errors.push(`Unexpected property at root: \"${k}\"`); });

    if (typeof deck.title !== 'string' || deck.title.trim().length < 1) {
      errors.push('"title" must be a non-empty string.');
    }

    if (!Number.isInteger(deck.version) || deck.version < 1) {
      errors.push('"version" must be an integer ≥ 1.');
    }

    if (!Array.isArray(deck.cards) || deck.cards.length < 1) {
      errors.push('"cards" must be a non-empty array.');
    }

    // Cards validation
    const ids = new Set();
    if (Array.isArray(deck.cards)) {
      deck.cards.forEach((card, idx) => {
        const path = `cards[${idx}]`;
        if (!isObject(card)) { errors.push(`${path} must be an object.`); return; }

        const allowedCardKeys = new Set(["id", "front", "back"]);
        Object.keys(card).forEach(k => { if (!allowedCardKeys.has(k)) errors.push(`Unexpected property at ${path}: \"${k}\"`); });

        if (!Number.isInteger(card.id) || card.id < 1) {
          errors.push(`${path}.id must be an integer ≥ 1.`);
        } else if (ids.has(card.id)) {
          errors.push(`${path}.id must be unique; duplicate id ${card.id}.`);
        } else { ids.add(card.id); }

        if (typeof card.front !== 'string' || card.front.trim().length < 1) {
          errors.push(`${path}.front must be a non-empty string.`);
        }

        if (!Array.isArray(card.back) || card.back.length < 1) {
          errors.push(`${path}.back must be a non-empty array of strings.`);
        } else {
          card.back.forEach((line, li) => {
            if (typeof line !== 'string' || line.trim().length < 1) {
              errors.push(`${path}.back[${li}] must be a non-empty string.`);
            }
          });
        }
      });
    }

    return { ok: errors.length === 0, errors };
  }

  // --- UI state ---
  const state = {
    deck: null,
    order: [],
    idx: 0,
    revealed: false,
  };

  // --- Elements ---
  const fileInput = document.getElementById('fileInput');
  const errorsEl = document.getElementById('errors');
  const controls = document.getElementById('controls');
  const meta = document.getElementById('meta');
  const cardEl = document.getElementById('card');
  const promptEl = document.getElementById('prompt');
  const answersEl = document.getElementById('answers');
  const answerListEl = document.getElementById('answerList');
  const hintEl = document.getElementById('hint');
  const cardCount = document.getElementById('cardCount')

  const loadJsonBtn = document.getElementById('loadJsonBtn');
  const prevBtn = document.getElementById('prevBtn');
  const flipBtn = document.getElementById('flipBtn');
  const nextBtn = document.getElementById('nextBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const restartBtn = document.getElementById('restartBtn');
  const demoBtn = document.getElementById('demoBtn');

  // --- Touch handling ---
  let touchStartX = 0;
  let touchStartTime = 0;

  cardEl.addEventListener('touchstart', (e) => {
    if (!state.deck) return;
    
    touchStartX = e.touches[0].clientX;
    touchStartTime = Date.now();
    
    // Remove any existing touch classes
    cardEl.classList.remove('touch-left', 'touch-right', 'touch-center');
  });

  cardEl.addEventListener('touchend', (e) => {
    if (!state.deck) return;
    
    const touchEndX = e.changedTouches[0].clientX;
    const touchEndTime = Date.now();
    const touchDuration = touchEndTime - touchStartTime;
    
    // Only process taps (not swipes)
    if (touchDuration > 500) return; // 500ms threshold for tap vs swipe
    
    const cardRect = cardEl.getBoundingClientRect();
    const touchX = touchEndX - cardRect.left;
    const cardWidth = cardRect.width;
    
    // Determine which area was touched
    if (touchX < cardWidth / 3) {
      // Left third - previous card
      if (state.idx > 0) {
        state.idx--;
        state.revealed = false;
        updateMeta();
        renderCard();
      }
    } else if (touchX > (cardWidth * 2) / 3) {
      // Right third - next card
      if (state.idx < state.order.length - 1) {
        state.idx++;
        state.revealed = false;
        updateMeta();
        renderCard();
      }
    } else {
      // Center third - flip card
      state.revealed = !state.revealed;
      renderCard();
    }
    
    // Remove touch feedback classes
    cardEl.classList.remove('touch-left', 'touch-right', 'touch-center');
  });

  // Add visual feedback during touch
  cardEl.addEventListener('touchmove', (e) => {
    if (!state.deck) return;
    
    const touchX = e.touches[0].clientX;
    const cardRect = cardEl.getBoundingClientRect();
    const relativeX = touchX - cardRect.left;
    const cardWidth = cardRect.width;
    
    // Remove existing classes
    cardEl.classList.remove('touch-left', 'touch-right', 'touch-center');
    
    // Add appropriate class based on touch position
    if (relativeX < cardWidth / 3) {
      cardEl.classList.add('touch-left');
    } else if (relativeX > (cardWidth * 2) / 3) {
      cardEl.classList.add('touch-right');
    } else {
      cardEl.classList.add('touch-center');
    }
  });

  // --- File loading ---
  loadJsonBtn.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', (e) => {
    const file = e.target.files && e.target.files[0];
    if (file) readFile(file);
    fileInput.value = '';
  });

  function readFile(file) {
    if (!/\.json$/i.test(file.name)) {
      showErrors([`File \"${file.name}\" is not a .json`]);
      return;
    }
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const text = reader.result;
        const parsed = JSON.parse(text);
        loadDeck(parsed, false); // false indicates JSON file loaded
      } catch (err) {
        showErrors([`Invalid JSON: ${err.message}`]);
      }
    };
    reader.onerror = () => showErrors([`Could not read file: ${reader.error?.message || 'Unknown error'}`]);
    reader.readAsText(file);
  }

  // --- Deck loading & rendering ---
  function loadDeck(deck, isDemo = true) {
    const res = validateDeck(deck);
    if (!res.ok) { showErrors(res.errors); return; }

    state.deck = deck;
    state.order = deck.cards.map((_, i) => i);
    state.idx = 0; state.revealed = false;

    hideErrors();
    controls.classList.remove('hidden');
    controls.setAttribute('aria-hidden', 'false');
    cardEl.classList.remove('hidden');
    meta.classList.remove('hidden');
    hintEl.classList.remove('hidden');

    // Hide demo button only when JSON is loaded (not demo)
    if (!isDemo) {
      demoBtn.classList.add('hidden');
    }

    updateMeta();
    renderCard();
  }

  function updateMeta() {
    if (!state.deck) return;
    meta.innerHTML = `<h2>${escapeHtml(state.deck.title)}</h2>`;
    cardCount.innerHTML = `Card ${state.idx + 1} / ${state.order.length}`;
  }

  function renderCard() {
    const deck = state.deck; if (!deck) return;
    const card = deck.cards[state.order[state.idx]];

    promptEl.textContent = card.front;

    // answers
    answerListEl.innerHTML = '';
    card.back.forEach(line => {
      const li = document.createElement('li');
      li.textContent = line;
      answerListEl.appendChild(li);
    });

    if (state.revealed) answersEl.classList.add('revealed');
    else answersEl.classList.remove('revealed');

    // buttons enable/disable
    prevBtn.disabled = state.idx === 0;
    nextBtn.disabled = state.idx === state.order.length - 1;
  }

  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[s]));
  }

  function showErrors(errs) {
    errorsEl.innerHTML = '';
    (Array.isArray(errs) ? errs : [String(errs)]).forEach(msg => {
      const div = document.createElement('div');
      div.className = 'error';
      div.textContent = msg;
      errorsEl.appendChild(div);
    });
    errorsEl.classList.remove('hidden');
  }
  function hideErrors() { errorsEl.classList.add('hidden'); errorsEl.innerHTML = ''; }

  // --- Controls ---
  prevBtn.addEventListener('click', () => { if (state.idx > 0) { state.idx--; state.revealed = false; updateMeta(); renderCard(); }});
  nextBtn.addEventListener('click', () => { if (state.idx < state.order.length - 1) { state.idx++; state.revealed = false; updateMeta(); renderCard(); }});
  flipBtn.addEventListener('click', () => { state.revealed = !state.revealed; renderCard(); });
  shuffleBtn.addEventListener('click', () => { shuffle(state.order); state.idx = 0; state.revealed = false; updateMeta(); renderCard(); });
  restartBtn.addEventListener('click', () => { state.idx = 0; state.revealed = false; updateMeta(); renderCard(); });

  document.addEventListener('keydown', (e) => {
    if (!state.deck) return;
    if (e.key === 'ArrowLeft') { e.preventDefault(); prevBtn.click(); }
    else if (e.key === 'ArrowRight') { e.preventDefault(); nextBtn.click(); }
    else if (e.key === ' ' || e.code === 'Space') { e.preventDefault(); flipBtn.click(); }
    else if (e.key.toLowerCase() === 's') { e.preventDefault(); shuffleBtn.click(); }
    else if (e.key.toLowerCase() === 'r') { e.preventDefault(); restartBtn.click(); }
  });

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // Demo deck (from schema example, slightly expanded)
  const demoDeck = {
    title: "Artificial Intelligence Fundamentals & Generative AI",
    version: 1,
    cards: [
      { id: 1, front: "What is Artificial Intelligence (AI)?", back: [
        "A computer system that imitates some aspect of human behavior or capabilities."] },
      { id: 2, front: "How does Generative AI differ from regular AI?", back: [
        "Regular AI imitates behaviors (recognize, classify, translate).",
        "Generative AI creates new content after training on existing data."] },
      { id: 3, front: "Name two forms of content created by Generative AI.", back: [
        "Text, images, code, audio, or video (any two)."] }
    ]
  };

  demoBtn.addEventListener('click', () => loadDeck(demoDeck, true)); // true indicates demo loaded
  </script>
</body>
</html>
